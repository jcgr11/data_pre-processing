import pandas as pd, datetime
import yfinance as yf
import seaborn as sns
from matplotlib import pyplot as plt
import matplotlib.dates as mdates
from matplotlib.dates import DateFormatter
from prophet import Prophet
from prophet.plot import add_changepoints_to_plot

#Download axp daily price date

df = yf.download ("AXP", 
                   start = "2020-03-31", 
                   end = "2023-03-31", 
                   progress = False, 
                   auto_adjust = True)["Close"]


# yahoo finance includes time in date-time for time series, must reset index to remove time for excel output
df1 = df.reset_index() # move date and time to axis 1 index 0
date = df1['Date'].dt.date # remove time stamp
ex_dt = df1.iloc[:,1:] # create new date only index column
axp = ex_dt.set_index(date) # set date column

axp.reset_index(inplace = True)
axp.columns = ["ds", "y"]
axp

# split the data into training and test sets
train_indices = axp["ds"].astype(str) < "2023-04-02"
df_train = axp.loc[train_indices].dropna()
df_test = (
    axp
    .loc[~train_indices]
    .reset_index(drop=True)
)

#set paramets for Meta Prophet algorithm
prophet = Prophet(changepoint_range=0.9)
prophet.add_country_holidays(country_name="US")
prophet.add_seasonality(
    name="weekly", period=365.25, fourier_order=5
)
prophet.fit(df_train)

#Original Time Series
axp.plot(title = "AXP Daily Price Movement", figsize=(20, 8))


# use the model to make predictions for the specified future date. seasonality is set to consider intra-week non-trading days in the date range chosen
df_future = prophet.make_future_dataframe(
    periods=120, freq="B"
)
df_pred = prophet.predict(df_future)
fig = prophet.plot(df_pred, figsize=(20, 8))
months = pd.date_range(axp["ds"].min(), df_future["ds"].max(), freq="MS")
plt.xticks(months, [month.strftime('%Y-%m') for month in months], rotation=45)
plt.show()

#show columns from prophet df
df_pred.columns

#add change points to predicted timeseries

fig = prophet.plot(df_pred, figsize=(20, 8))
a = add_changepoints_to_plot(
    fig.gca(), prophet, df_pred
)

#decompose the timeseries
prophet.plot_components(df_pred, figsize = (18, 8))

#remove seasonality and other unncessary columns generated by prophet algorithm, extract only date series predicted value, upper and lower bounds
SELECTED_COLS = [
    "ds", "yhat", "yhat_lower", "yhat_upper"
]
df_pred = (
    df_pred
    .loc[:, SELECTED_COLS]
    .reset_index(drop=True)
)
df_pred= df_pred.set_index("ds")


#Remove timestamp from df_pred and prepare to merge with original axp timeseries

df_pred1 = df_pred.reset_index() # move date and time to axis 1 index 0
df_pred_dt = df_pred1['ds'].dt.date # remove time stamp
df_pred_ex_dt = df_pred1.iloc[:,1:] # create new date only index column
df_pred_merge = df_pred_ex_dt.set_index(df_pred_dt) # set date column

df_pred_merge.reset_index(inplace=True)

#Merge original time series with predications and tested data & rename columns to prepare for plotting

combined_df = pd.merge(axp, df_pred_merge[['ds', 'yhat', 'yhat_lower', 'yhat_upper']], on='ds', how='outer')

combined_df = combined_df.rename(columns={
    "ds": "Date",
    "y": "Actual",
    "yhat": "Predicted",
    "yhat_lower": "Lower Bound",
    "yhat_upper": "Upper Bound"
})

combined_df.set_index("Date", inplace=True)

#set up plotting parameters and generate plot

fig, ax = plt.subplots(1, 1, figsize=(20, 8))

PLOT_COLS = [
    "Actual", "Predicted", "Upper Bound", "Lower Bound",
]
sns.lineplot(data=combined_df[PLOT_COLS], ax=ax)
ax.fill_between(
    combined_df.index,
    combined_df["Lower Bound"],
    combined_df["Upper Bound"],
    alpha=0.25,
)

# Format x-axis ticks
date_form = mdates.DateFormatter("%Y-%m")
ax.xaxis.set_major_formatter(date_form)
ax.xaxis.set_major_locator(mdates.MonthLocator())
ax.xaxis.set_tick_params(rotation=45)

# Set x-axis limits
ax.set_xlim([datetime.date(2020, 3, 15), combined_df.index.max()])

# Add gridlines
ax.grid(True, which='major', axis='both', linestyle='--', color='gray', alpha=0.5)

ax.set(
    title="AXP Timeseries Forecast",
    xlabel="Date",
    ylabel="AXP - Actual vs. Predicted"
)

plt.show()

#Display the expected value as of the end of the forecasted timeseries
forecasted_value = combined_df.iloc[-1,1]
print("Forecasted value for 2023-09-14:", forecasted_value)
